# xv6

`fork()`父进程创建子进程时，子进程**复制**父进程的内存空间、堆栈、代码、数据等，在另一块内存区域保存。**两者并不共享内存区域**  

- 当我们采用fork时，子进程并不会一开始就复制父进程的内存。相反会共享内存空间，当一个进程尝试修改共享的内存时，操作系统才会真正复制。-->虚拟内存技术 (copy-on-write)

`wait()`用来等待子进程结束，获得子进程退出状态返回给父进程。若没有子进程退出**wait会一直等待，知道有一个退出为止**。如果父进程不关注子进程退出状态就采用`wait(0)`  

`exec()`将内存中原有代码数据被新程序取代-->意味着exec允许一个进程在运行时切换到不同的程序

`close()`关闭进程中某个文件描述符，让其可以复用 

`dup()`创建一个现有文件描述符的副本，允许多个文件描述符引用相同的文件或资源，**关闭其中一个并不会影响另一个** ，共享文件偏移量

- `dup()`会自动将副本赋值给当前进程的**最小未使用**文件描述符

**文件描述符表中每一个条目都包含了文件指针、文件状态、偏移量、引用计数等。而文件描述符只是其索引**

- 0-->标准输入
- 1-->标准输出
- 2-->标准error

***

**pipe实质上是小的内存缓冲区**，暴露给进程两个文件描述符，一个往进写，一个往出读

- fd[0]-->从管道读
- fd[1]-->往管道写


```cpp
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
	close(0);
	dup(p[0]);
	close(p[0]);
	close(p[1]);
	exec("/bin/wc", argv);
} else {
	close(p[0]);
	write(p[1], "hello world\n", 12);
	close(p[1]);
}
```

其中close(p[0]),close(p[1])是因为p[0]已经被复制到 0 文件描述符了 然后关闭子进程中管道的读端写端 这样子进程就可以写入管道

***



`Mknod()` 创建的是一个设备文件

当进程打开一个设备文件时，内核会将 read write 转移到内核实现

`link()` 系统调用创建另一个文件的名称 两者共享一个inode 实现如下：

> ```c++
> open("a",O_CREATW|O_WRONLY);
> link("a","b");
> ```



**`cd` 命令并不像其他命令一样创建一个子进程 **

***

## Lecture 1:

文件描述符为每个正在运行的程序提供内核中索引

当使用 fork 创建一个进程时 在父进程中返回子进程的pid 在子进程中返回 0 代表子进程正在运行

平常在shell中输入命令 其实就是shell进程创建了一个子进程 来执行命令程序

fork 和 exec通常结合使用 是因为需要父进程和子进程执行不同程序 exec可以将复制过来的父进程代码转换成自己需要运行的

***

## Lab 1：

pipe是半双工的，所以当父子进程要进行相互通信时，必须要使用两个。使用一个会造成竞态条件，例如两个进程同时往里写同时往外读。

> 管道没有锁机制，因此如果在这种情况下使用管道，需要自行设计管道管理

关于**primes lab**：

1. 在使用pipe时，记住pipe是个缓冲区，可以通过循环一个个写入。并不用直接全部输入进去。等到传输的东西都输入进pipe后，再fork用子进程去读取。写完记得关闭写的文件描述符。
2. exit(0)与wait(0)前者是终止当前进程，后者是让父进程等待一个子进程的结束。父进程会阻塞在这里，直到有一个子进程结束。
3. 若当前进程没有创建子进程，当使用wait()时，就会立刻返回，不起任何作用

关于**find lab**:

1. stat()是一个路径指定的文件信息，fstat()则是通过一个文件描述符来查看文件信息
2. 养成用完文件描述符就关闭的习惯
3. memmove()内存复制的标准库函数`memmove(p, de.name, DIRSIZ)`将de.name所指复制到p所指空间中，复制DIRSIZ大小

关于**xargs lab**:

1. `echo hello too | xargs echo bye`在这句命令中，xargs接收到的argc=3 分别是 xargs名本身 以及 echo 和 bye。所以有了下面这段代码:
```c++ 
for(int i=1;i<argc;i++){
     args[i-1]=argv[i];
    }.....
 ..... 
	args[argc-1]=buf;//让传过来的参数附加到参数列表里
        if(exec(argv[1],args)<0){//argv[0]是xargs本身 
           fprintf(2,"exec: error\n");
    }
```

2. xargs是从**standard input**中读取数据 也就是标准输入 而不是standard output!

***

操作系统必须满足三个要求：**multiplexing(多路复用)，isolation(隔离),interaction(交互)**

系统调用system call就是抽象了计算机资源的接口，实现了应用程序和硬件的隔离

为了实现application之间的隔离，即一个崩溃了不影响其他运行，cpu提供了硬件支持。RISC-V有三种cpu执行的模式：**machine mode,supervisor mode, user mode**. application想要调用内核函数通过系统调用,就必须切换到内核。这时cpu会通过一个指令从user mode 转换到 supervisor mode(在RISC-V中是ecall)，**并在内核指定入口点进入内核**，切换mode后，内核决定是否进行执行application的执行请求。

> 系统调用和内核函数的区别：系统调用是application访问内核功能的接口，而内核函数是在操作系统内核汇总的函数，执行内核功能例如进程管理、内存管理等。**内核函数通常是内核内部使用的函数，而系统调用是用户空间应用程序使用的接口**

**Monolithic Kernel** 单体内核，即整个操作系统都在内核中，所有的系统调用都以supervisor mode 执行。（windows ，linux,macOS都是这种设计）

> 在单体内核模式下，若某一个系统调用出错，因为此时cpu是supervisor mode 拥有绝对的所有权，因此可能会导致整个内核崩溃。为了减少这种风险，人们减少了在supervisor mode下运行的代码量，将大部分代码在user mode下运行

以上想法就是**Microkernel**，将核心功能分成小模块，通过消息传递等机制进行模块间通信

每一个进程都有一个执行线程，专门用来执行指令。执行线程挂起时，相关状态保存在线程自己的栈中。

每一个进程都有两个栈，一个 user stack 一个kernel stack。当执行用户指令时，使用user stack，反之，进程进入内核时，代码就会在kernel stack上执行。

**xv6的启动和第一个进程执行过程：**

1. 当RISC-V计算机通电时，先初始化自己，然后运行在read-only memory里的加载程序。加载程序将xv6的内核加载到内存，在machine mode下，在`_entry`处开始执行xv6。（在这里RISC-V为了引导简化和初期启动要求禁用了分页硬件，由虚拟地址直接映射到物理地址）
2. 加载程序将xv6内核加载到物理地址较高的地方，在本文中是0x80000000.原因是低地址通常保留用于系统的重要部分，比如I/O映射。
3. 在machine mode下进行一些配置，然后切换到supervisor mode，RISC-V提供`mret`指令，该指令原本意为从machine mode 切换为原来的特权级别。而在这里，它执行的是将mstatus中设置为supervisor, 将main()的地址写入寄存器以作为返回地址，将所有中断和异常授权于supervisor mode. 配置定时器以产生定时器中断，将程序计数器设置为main()的地址，以开始执行操作系统内核主要代码。
4. 在main()初始化一些设备和子系统后，例如page table,cache等，开始创建第一个进程，第一个进程执行RISC-V中的exec，执行用户空间的`/init`,这个程序会创建一个新的console device file 然后将其文件描述符 0 1 2打开，在上面启动一个shell

***

## Lecture 2:

**所有的处理器，若需要运行能够支持多个app的操作系统，那么它就需要同时支持user/kernel mode和虚拟内存**

application cannot crush the OS，app不能打破自身隔离 因此OS要被设计为防御性的 这意味着**app和OS之间应该有强隔离性** <----硬件支持（user/kernel mode或者 virtual memory）

页表实现从虚拟地址映射到物理地址，每一个进程拥有自己的页表-->强的内存隔离

在RSIC-V中，我们在用户空间直接使用fork()创建子进程背后逻辑是：编译时通过ecall指令切换到kernel, 而在kernel中会有一个syscall.c文件通过寄存器读取要调用的系统调用，再执行内核中的fork()进行创建

**在单核场景下，单个断点就可以停止整个程序的运行**

***

## Lab 2：

整个Lab 2是让我们熟悉系统调用在xv6系统中的执行过程。

关于**trace lab**：

1. 通过在用户空间中user.h中**声明**我们的跟踪函数 `int trace(int);`
2. 编译时，通过perl脚本生成RISC-V汇编语言，将SYS_trace存入寄存器a7(a7寄存器在xv6系统中专门存储各种系统调用的号码)。再通过`ecall`指令进入内核状态！！
3. 在内核状态，会跳转到`syscall()`系统调用通用入口，去找到对应系统调用函数。从寄存器a7中读取出号码，与系统调用的表对应执行系统调用函数。返回值存在寄存器a0里。
4. 执行完毕后，利用`argint()`从用户空间获得参数，若此时执行的系统调用在所获取参数范围内，按照要求打印这次系统调用的信息。
5. 从`ecall`中结束，通过`ret`指令返回用户空间

关于**sysinfo lab**:

1. 声明的是一个结构体指针，如果要对其成员进行赋值，需要对这个指针给予空间，否则会导致内核崩溃。要么赋予空间，要么直接申请结构体变量而不是结构体指针。
2. xv6内核，采用的是一个单链表管理空闲内存，每一页是4096 bytes

***

页表用于将程序的虚拟地址映射到**物理内存**中的实际物理地址。（是物理内存而不是物理硬盘）