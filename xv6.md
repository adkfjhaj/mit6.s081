# xv6

`fork()`父进程创建子进程时，子进程**复制**父进程的内存空间、堆栈、代码、数据等，在另一块内存区域保存。**两者并不共享内存区域**  

- 当我们采用fork时，子进程并不会一开始就复制父进程的内存。相反会共享内存空间，当一个进程尝试修改共享的内存时，操作系统才会真正复制。-->虚拟内存技术 (copy-on-write)

`wait()`用来等待子进程结束，获得子进程退出状态返回给父进程。若没有子进程退出**wait会一直等待，知道有一个退出为止**。如果父进程不关注子进程退出状态就采用`wait(0)`  

`exec()`将内存中原有代码数据被新程序取代-->意味着exec允许一个进程在运行时切换到不同的程序

`close()`关闭进程中某个文件描述符，让其可以复用 

`dup()`创建一个现有文件描述符的副本，允许多个文件描述符引用相同的文件或资源，**关闭其中一个并不会影响另一个** ，共享文件偏移量

- `dup()`会自动将副本赋值给当前进程的**最小未使用**文件描述符

**文件描述符表中每一个条目都包含了文件指针、文件状态、偏移量、引用计数等。而文件描述符只是其索引**

- 0-->标准输入
- 1-->标准输出
- 2-->标准error

***

**pipe实质上是小的内存缓冲区**，暴露给进程两个文件描述符，一个往进写，一个往出读

- fd[0]-->从管道读
- fd[1]-->往管道写


```cpp
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
	close(0);
	dup(p[0]);
	close(p[0]);
	close(p[1]);
	exec("/bin/wc", argv);
} else {
	close(p[0]);
	write(p[1], "hello world\n", 12);
	close(p[1]);
}
```

其中close(p[0]),close(p[1])是因为p[0]已经被复制到 0 文件描述符了 然后关闭子进程中管道的读端写端 这样子进程就可以写入管道

***



`Mknod()` 创建的是一个设备文件

当进程打开一个设备文件时，内核会将 read write 转移到内核实现

`link()` 系统调用创建另一个文件的名称 两者共享一个inode 实现如下：

> ```c++
> open("a",O_CREATW|O_WRONLY);
> link("a","b");
> ```



**`cd` 命令并不像其他命令一样创建一个子进程 **

***

## Lecture 1:

文件描述符为每个正在运行的程序提供内核中索引

当使用 fork 创建一个进程时 在父进程中返回子进程的pid 在子进程中返回 0 代表子进程正在运行

平常在shell中输入命令 其实就是shell进程创建了一个子进程 来执行命令程序

fork 和 exec通常结合使用 是因为需要父进程和子进程执行不同程序 exec可以将复制过来的父进程代码转换成自己需要运行的

***

## Lab 1：

pipe是半双工的，所以当父子进程要进行相互通信时，必须要使用两个。使用一个会造成竞态条件，例如两个进程同时往里写同时往外读。

> 管道没有锁机制，因此如果在这种情况下使用管道，需要自行设计管道管理

关于**primes lab**：

1. 在使用pipe时，记住pipe是个缓冲区，可以通过循环一个个写入。并不用直接全部输入进去。等到传输的东西都输入进pipe后，再fork用子进程去读取。写完记得关闭写的文件描述符。
2. exit(0)与wait(0)前者是终止当前进程，后者是让父进程等待一个子进程的结束。父进程会阻塞在这里，直到有一个子进程结束。
3. 若当前进程没有创建子进程，当使用wait()时，就会立刻返回，不起任何作用

关于**find lab**:

1. stat()是一个路径指定的文件信息，fstat()则是通过一个文件描述符来查看文件信息
2. 养成用完文件描述符就关闭的习惯
3. memmove()内存复制的标准库函数`memmove(p, de.name, DIRSIZ)`将de.name所指复制到p所指空间中，复制DIRSIZ大小

关于**xargs lab**:

1. `echo hello too | xargs echo bye`在这句命令中，xargs接收到的argc=3 分别是 xargs名本身 以及 echo 和 bye。所以有了下面这段代码:
```c++ 
for(int i=1;i<argc;i++){
     args[i-1]=argv[i];
    }.....
 ..... 
	args[argc-1]=buf;//让传过来的参数附加到参数列表里
        if(exec(argv[1],args)<0){//argv[0]是xargs本身 
           fprintf(2,"exec: error\n");
    }
```

2. xargs是从**standard input**中读取数据 也就是标准输入 而不是standard output!